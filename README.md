# delta-compiler-bip
Compiler for the Delta toy programming language to BIP assembly.\
Lexer and parser (SLR(1)) were generated by GALS (Gerador de analisador léxico e sintático).

Syntax: ```delta [options] [filepath]```

```[options]```
```-watch```: Prints Bhaskara (IDE) information in console;
```-debug```: Prints debugging information in console;

```[filepath]```: Relative or absolute path of .delta file to be compiled.

## Features
Variables and datatypes - Integer (int), Character (char), Boolean (bool) and Void (void):
```c
int a = 5;
char b = 'x';
boolean c = true;
```
Single-line and multi-line comments:
```c
// I'm a single-lined comment

/*
I'm a
multi-lined
comment
*/
```
Expressions - Addition, subtraction, bit OR, bit XOR, bit AND, bit LS, bit RS (usable with assignment operator):
```c
int value = 4 + 4 - 2;
int dividedByTwo = value << 2;
int negated = ~value;

int incrementAssign = 4;
incrementAssign += 2; // "incrementAssign" now contains 6
```
Unary operators:
```c
int unary = 0;
unary--; // expression returns 0 and "unary" contains -1

unary = 0;
--unary; // expression returns -1 and "unary" contains -1

unary = 0;
unary++; // expression returns 0 and "unary" contains 1

unary = 0;
++unary; // expression returns 1 and "unary" contains 1
```
Single-dimension arrays for any datatype:
```c
int[3] array;
array[0] = 10;
array[1] = array[0] + 15;
```
Control structures: if, elseif, else, while, for, do while and when-is (switch-case statement):
```c
int[3] array;
array[0] = 20;
array[1] = 15;
array[2] = 10;

// Bubblesort
for (int i = 0; i < 3 - 1; i++) {
  for (int j = 0; j < 3 - i - 1; j++) {
    if (array[j] > array[j + 1]) {
      int temp = array[j];
      array[j] = array[j + 1];
      array[j + 1] = temp;
    }
  }
}

// Print all elements
for (int i = 0; i < 3; i++) {
  print(array[i]);
}
```
```c
int number = 42;
bool quit = false;

// Guess the number
while (!quit) {
  int choice = input();

  if (choice > number) {
    print(1); // lower!
  } elseif (choice < number) {
    print(2); // higher!
  } else {
    print(3); // you won!
    quit = true;
  }
}
```
Input and output:
```c
int a = 3;
print(a); // prints 3

char c = 'f';
print(c); // prints 102 (ASCII equivalent)

int n = input(); // takes integer number from user
```
Assembly generated for bubblesort:
```
.data
	array_0: 0, 0, 0
	i_1: 0
	j_2: 0
	temp_3: 0
	i_4: 0

.text
	LDI 0
	STO 1000
	LDI 20
	STO 1001
	LD 1000
	STO $indr
	LD 1001
	STOV array_0
	LDI 1
	STO 1000
	LDI 15
	STO 1001
	LD 1000
	STO $indr
	LD 1001
	STOV array_0
	LDI 2
	STO 1000
	LDI 10
	STO 1001
	LD 1000
	STO $indr
	LD 1001
	STOV array_0
	LDI 0
	STO 1000
	LD 1000
	STO i_1
for_start_0:
	LD i_1
	STO 1000
	LDI 3
	STO 1001
	LDI 1
	STO 1002
	LD 1001
	SUB 1002
	STO 1001
	LD 1000
	SUB 1001
	STO 1001
	LD 1001
	SRL 10
	ANDI 1
	STO 1000
	LD 1000
	BEQ for_end_0
	LDI 0
	STO 1000
	LD 1000
	STO j_2
for_start_1:
	LD j_2
	STO 1000
	LDI 3
	STO 1001
	LD i_1
	STO 1002
	LD 1001
	SUB 1002
	STO 1001
	LDI 1
	STO 1002
	LD 1001
	SUB 1002
	STO 1001
	LD 1000
	SUB 1001
	STO 1001
	LD 1001
	SRL 10
	ANDI 1
	STO 1000
	LD 1000
	BEQ for_end_1
	LD j_2
	STO 1000
	LD 1000
	STO $indr
	LDV array_0
	STO 1000
	LD j_2
	STO 1001
	LDI 1
	STO 1002
	LD 1001
	ADD 1002
	STO 1001
	LD 1001
	STO $indr
	LDV array_0
	STO 1001
	LD 1000
	SUB 1001
	STO 1001
	LD 1001
	SRL 10
	ANDI 1
	STO 1002
	LD 1001
	SRL 10
	ANDI 1
	STO 1003
	LD 1001
	NOT 0
	ADDI 1
	SRL 10
	ANDI 1
	OR 1003
	XORI 1
	STO 1003
	LD 1002
	XORI 1
	STO 1002
	LD 1003
	XORI 1
	AND 1002
	STO 1000
	LD 1000
	BEQ if_end_2
	LD j_2
	STO 1000
	LD 1000
	STO $indr
	LDV array_0
	STO 1000
	LD 1000
	STO temp_3
	LD j_2
	STO 1000
	LD j_2
	STO 1001
	LDI 1
	STO 1002
	LD 1001
	ADD 1002
	STO 1001
	LD 1001
	STO $indr
	LDV array_0
	STO 1001
	LD 1000
	STO $indr
	LD 1001
	STOV array_0
	LD j_2
	STO 1000
	LDI 1
	STO 1001
	LD 1000
	ADD 1001
	STO 1000
	LD temp_3
	STO 1001
	LD 1000
	STO $indr
	LD 1001
	STOV array_0
	JMP if_stmt_end_2
if_end_2:
if_stmt_end_2:
	LD j_2
	STO 1000
	ADDI 1
	STO j_2
	JMP for_start_1
for_end_1:
	LD i_1
	STO 1000
	ADDI 1
	STO i_1
	JMP for_start_0
for_end_0:
	LDI 0
	STO 1000
	LD 1000
	STO i_4
for_start_3:
	LD i_4
	STO 1000
	LDI 3
	STO 1001
	LD 1000
	SUB 1001
	STO 1001
	LD 1001
	SRL 10
	ANDI 1
	STO 1000
	LD 1000
	BEQ for_end_3
	LD i_4
	STO 1000
	LD 1000
	STO $indr
	LDV array_0
	STO 1000
	LD 1000
	STO $out_port
	LD i_4
	STO 1000
	ADDI 1
	STO i_4
	JMP for_start_3
for_end_3:
	HLT 0
```
