#Options
GenerateScanner = true
GenerateParser = true
Language = C++
ScannerName = Lexico
ParserName = Sintatico
SemanticName = Semantico
ScannerCaseSensitive = true
ScannerTable = Full
Input = Stream
Parser = SLR
#RegularDefinitions
LS : [^\"]|(\\\")
LC : [^']|(\\')
D : [0-9]

DEC : [0-9]+
HEX : 0[xX][0-9a-fA-F]+
BIN : 0[bB][01]+

CMT: (/\*([^\*]|[\r\n]|(\*+([^\*/]|[\r\n])))*\*+/)|([/][/].*)
#Tokens
INT_DEC : {DEC}
INT_HEX : {HEX}
INT_BIN : {BIN}
FLOAT : {D}+(\.{D}+)?f?
STRING : \"{LS}*\"
CHAR : '{LC}?'
BOOLEAN : (true|false)

VAR_INT: int
VAR_FLOAT: float
VAR_DOUBLE: double
VAR_STRING: string
VAR_CHAR: char
VAR_BOOLEAN: boolean
VAR_VOID: void

CONST : const
REF: ref
IF : if
ELSE : else
ELSEIF : elseif
WHILE : while
DO: do
FOR : for
WHEN : when
IS : is
RETURN : return
DEFAULT : default
PRINT : print
INPUT : input

AND : (and|&&)
OR : (or|\|\|)
NOT : (not|!)

GREATER: >
SMALLER: <
GREATER_EQ: >=
SMALLER_EQ: <=
EQ: ==
DIF: !=

INCREMENT_ATTRIBUTION: \+=
DECREMENT_ATTRIBUTION: \-=

INCREMENT: \+\+
DECREMENT: \-\-
PLUS: \+
MINUS: \-
MULT: \*
DIV: /
MOD: %
ATTRIBUTION: =

BIT_AND: &
BIT_OR: \|
BIT_XOR: \^
BIT_NOT: ~
BIT_RS: >>
BIT_LS: <<

LSP : \(
RSP : \)
LSB : \[ 
RSB : \]
LSC : \{
RSC : \}
DOT : \.
END : ;
COLON : :
COMMA : ,

ID : [a-zA-Z_$][a-zA-Z_0-9$]*

: {CMT}
: [\s\t\n\r ]*


#NonTerminals
// Escopo global
<global>
<global_stmt>

// Escopos e funções
<scope>
<function>
<function_prototype>
<function_prototype_argument_list>

<function_call>
<function_call_argument_list>

// Statements
<statement_list>
<statement>

<if_stmt>
<while_stmt>
<do_while_stmt>

<for_stmt>
<for_left>

<when_stmt>

<declaration_stmt>
<declaration_stmt_id_list>

<attribution_stmt>
<return_stmt>

// Blocos
<if>
<else_if>
<else_if_list>
<else>

<is_list>
<is>
<default>

// Expressões
<exp>
<exp1>
<exp2>
<exp3>
<exp4>
<exp5>
<exp6>
<exp7>
<exp8>
<exp9>
<exp10>
<exp11>

<type>
<type_primitive>
<modifier_list>

<int_literal>
<literal>
<left_value>
<right_value>

// Operadores
<op_comp>
<op_unary_right_mutable>
<op_unary_left>
<op_unary_left_mutable>
<op_bitwise>
<op_arit_low>
<op_arit_high>
<op_attribution>

#Grammar
// Escopo global
<global> ::= <global_stmt> <global> | <global_stmt>;
<global_stmt> ::= <declaration_stmt> END | <attribution_stmt> END | <function>;

// Escopos e funções
<scope> ::= LSC RSC | LSC <statement_list> RSC;
<function> ::= <function_prototype> #80 #76 <scope> #50;
<function_prototype> ::= <type> ID #74 LSP RSP | <type> ID #74 LSP <function_prototype_argument_list> RSP;
<function_prototype_argument_list> ::= <type> ID #75 COMMA <function_prototype_argument_list> | <type> ID #75;

<function_call> ::= ID #77 LSP RSP #79 | ID #77 LSP <function_call_argument_list> RSP #79 | PRINT LSP <exp> RSP #82 | INPUT LSP RSP #83;
<function_call_argument_list> ::= <exp> #78 COMMA <function_call_argument_list> | <exp> #78;

// Statements
<statement_list> ::= <statement> <statement_list> | <statement>;
<statement> ::= <if_stmt> | <while_stmt> | <do_while_stmt> END | <for_stmt> | <declaration_stmt> END | <attribution_stmt> END | <return_stmt> END | <exp> END | <when_stmt>;

<if_stmt> ::= <if> | <if> <else> | <if> <else_if_list> | <if> <else_if_list> <else>;
<while_stmt> ::= WHILE LSP <exp> #68 RSP #49 <scope> #50;
<do_while_stmt> ::= DO #49 <scope> #50 WHILE LSP <exp> #69 RSP;

<for_stmt> ::= FOR #49 LSP <for_left> END <exp> #70 END <exp> RSP <scope> #50;
<for_left> ::= <exp> | <declaration_stmt> | <attribution_stmt>;

<when_stmt> ::= WHEN LSP <exp> #71 RSP LSC <is_list> RSC #73;

<declaration_stmt> ::= <type> <declaration_stmt_id_list> #62;
<declaration_stmt_id_list> ::= ID #61 COMMA <declaration_stmt_id_list> | ID #61 ATTRIBUTION #46 <exp> #63 COMMA <declaration_stmt_id_list> | ID #61 | ID #61 ATTRIBUTION #46 <exp> #63;

<attribution_stmt> ::= <left_value> #64 <op_attribution> <exp> #63 #65;
<return_stmt> ::= RETURN <exp> #81;

// Blocos
<if> ::= IF LSP <exp> #66 RSP #49 <scope> #50;
<else_if_list> ::= <else_if> <else_if_list> | <else_if>;
<else_if> ::= ELSEIF LSP <exp> #67 RSP #49 <scope> #50;
<else> ::= ELSE #49 <scope> #50;

<is_list> ::= <is> <is_list> | <default> | <is>;
<is> ::= IS LSP <exp> #72 RSP <scope>;
<default> ::= DEFAULT <scope>;

// Expressões
<exp>   ::= <exp> OR #21 <exp1> #10 | <exp1>;
<exp1>  ::= <exp1> AND #22 <exp2> #11 | <exp2>;
<exp2>  ::= <exp2> BIT_OR #23 <exp3> #12 | <exp3>; 
<exp3>  ::= <exp3> BIT_XOR #24 <exp4> #13 | <exp4>;
<exp4>  ::= <exp4> BIT_AND #25 <exp5> #14 | <exp5>;
<exp5>  ::= <exp5> <op_comp> <exp6> #15 | <exp6>;
<exp6>  ::= <exp6> <op_bitwise> <exp7> #16 | <exp7>;
<exp7>  ::= <exp7> <op_arit_low> <exp8> #17 | <exp8>;
<exp8>  ::= <exp8> <op_arit_high> <exp9> #18 | <exp9> ;
<exp9>  ::= <left_value> #9 <op_unary_right_mutable> #19 | <exp10>;
<exp10> ::= <op_unary_left> <left_value> #9 #20 | <op_unary_left_mutable> <left_value> #9 #20 | <op_unary_left> <right_value> #20 | <exp11>;
<exp11> ::= <literal> | <left_value> #9 | <function_call> | LSP <exp> RSP;

<type> ::= <modifier_list> <type_primitive> | <modifier_list> <type_primitive> LSB <int_literal> #60 RSB;
<type_primitive> ::= VAR_INT #53 | VAR_FLOAT #54 | VAR_DOUBLE #55 | VAR_STRING #56 | VAR_CHAR #57 | VAR_BOOLEAN #58 | VAR_VOID #59;
<modifier_list> ::= CONST #52 | î;

<int_literal> ::= INT_DEC | INT_HEX | INT_BIN;
<literal> ::= <int_literal> #1 | FLOAT #2 | STRING #3 | CHAR #4 | BOOLEAN #5;
<left_value> ::= ID #6 | ID #7 LSB <exp> #8 RSB;
<right_value> ::= <literal> | <function_call> | LSP <exp> RSP;

// Operadores
<op_comp> ::= GREATER #26 | SMALLER #27 | GREATER_EQ #28 | SMALLER_EQ #29 | EQ #30 | DIF #31;
<op_bitwise> ::= BIT_LS #32 | BIT_RS #33;
<op_arit_low> ::= PLUS #34 | MINUS #35;
<op_arit_high> ::= MULT #36 | DIV #37 | MOD #38;
<op_unary_right_mutable> ::= INCREMENT #39 | DECREMENT #40;
<op_unary_left> ::= MINUS #41 | BIT_NOT #42 | NOT #43;
<op_unary_left_mutable> ::= INCREMENT #44 | DECREMENT #45;
<op_attribution> ::= ATTRIBUTION #46 | INCREMENT_ATTRIBUTION #47 | DECREMENT_ATTRIBUTION #48;

// Exemplo com tudo para ser usado no simulador
// -x + 8.8 - !x * 2 / ~y % 3 << 7 != y >> 3 || (x <= 3 && y > 8) | p & (h ^ g)
